# .NET 浮点数存储

## 前言

众所周知，不是所有的实数在计算机中都能完成表示出来的，尤其是小数，只能表示其近视值。  
在计算机中，浮点是一种对于实数的近似值数值表现法，由一个有效数字（即尾数）加上幂数来表示，通常是乘以某个基数的整数次指数得到。以这种表示法表示的数值，称为浮点数（floating-point number）。利用浮点进行运算，称为浮点计算，这种运算通常伴随着因为无法精确表示而进行的近似或舍入。

目前，计算机使用的浮点数，是采用IEEE标准的浮点数的存储和计算方式。根据IEEE标准，浮点数是通过科学计数法来存储的，如下显示

![avatar](..\..\images\1.png)

浮点数在计算机中的存储分为三个部分： 

1. 符号位（sign）：float和double符号位均为1位，0代表正数，1代表负数 
2. 指数位（exponent）：存储科学计数法中的指数部分，采用移位存储 
3. 尾数位（fraction）：存储科学计数法中的尾数部分

![avatar](..\..\images\2.png)


根据IEEE 754标准，单精度float类型使用32比特存储，其中1位表示符号，8位表示指数，23位表示尾数；双精度double类型使用64比特存储，1位符号位，11位指数位，52位尾数位。

![avatar](..\..\images\3.png)

---


## 浮点数的精度与范围

说到浮点数，一般都会说起浮点数的精度。  
浮点数的精度指的是浮点数与实数之间的近似程度。  
而浮点数的范围，指的是浮点数能表示的数值范围。

文字描述显得有些难以理解，下面我们以一个例子来说明浮点数的精度和数值范围。

```c#
//C# program
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Globalization;

namespace TypeTest
{
	class Program
	{
		static void Main(string[] args)
		{
			Double ad = 142726.24d;
			float  af = 142726.24f;
			Console.WriteLine("af: {0}; ad: {1}", af, ad);
		}
	}
}
```

我们以上面的代码为例子，通过查看`ad`、`af`这两个变量在内存中的值，来倒推出来浮点数（单双精度）是如何在计算机中存储的。

### 1、单精度 float

#### 正序

首先，我们按照第一节所述的指数和小数的方式，把`142726.24f`转换为二进制的方式。

第一，分别把整数部分`142726` 和小数部分`.24` 转换为二进制格式，如下所示：

	142726.24f
	100010110110000110.00111101011100001010001111010111

第二，将转换后的二进制格式数据，转变为二进制科学计数的方式，如下所示：

	100010110110000110.00111101011100001010001111010111
	1.0001011011000011000111101011100001010001111010111 * 2^17

第三，通过第二步骤，分别得到了小数部分（1.0001011011....）和指数部分（17），分别存储指数部分和小数部分。  
需要说明的是：  
**小数部分中的小数点前面的 `1` 是固定的，因此只需要存储小数点后面的部分即可。**  
**指数部分中指数是有符号整数，可正可负。指数部分使用8位比特存储数据，数值范围为`-126 ~ 127`，为了消除负数带来的计算的影响，因此存在一个偏移量 `127` ，存储指数的时候，先把指数加上这个偏移量，再进行存储，这样就不会存在负数了。**

因此，小数部分（23位比特存储）,指数部分（8位比特存储）的方式，可以得到：

	00010110110000110001111			(小数部分)
	17 + 127 = 144 => 10010000		(指数部分)
	0								(符号位)
	// 结合起来就是
	0 10010000 00010110110000110001111
	=>
	01001000000010110110000110001111
	=>
	0X01001000000010110110000110001111


关于小数部分，如果超过了`23`位比特，系统截取的方式，**个人猜测是采用末位进位的方式**，如果第`24`位的值为`1`，则二进制进位`1`,如果第`24`位的值为`0`，则不进位。

	000101101100001100011110
	00010110110000110001111		(截取23位后的结果，第24位为0，所以不进位)
	
	001111010111000010100011
	00111101011100001010010		(截取23位后的结果，第24位为1，进位1。再与第23位的1相加，再进位，得到结果)



#### 逆序

在VS2010中，通过设置断点，然后在内存窗口中输入变量的地址，即可查看到变量在内存的值。

![avatar](..\..\images\4.png)

在Address中输入 `&af` ，则会跳到变量 `af` 的位置上。如图中划红线的部分 `0x05C6EB80` 就是变量的地址，其值是后面紧跟的部分。

那么该取多少个呢？  
由前面的知识，可以知道float单精度浮点数使用32位比特存储，VS2010显示的内存值为16进制格式,每个16进制值表示4位二进制比特。32/4 = 8。因此，`af`在内存中的值为：  

	8f 61 0b 48

从左往右，表示的是内存的低地址到高地址。而VS2010采用小端存储模式存储数据，即低地址存储低位字节序内容，因此，其二进制的值应该为：

	48 0b 61 8f

转换为二进制格式就是：

	01001000 00001011 01100001 10001111
	=>
	0X01001000000010110110000110001111


#### 还原

将正序的得到的结果与逆序得到的结果对比

	0X01001000000010110110000110001111
	0X01001000000010110110000110001111

结果一致。

将二进制结果还原。

	01001000000010110110000110001111
	=>
	0   10010000   00010110110000110001111
	=>
	1.00010110110000110001111 * 2^(10010000 - 127)
	=>
	1.00010110110000110001111 * 2^(144 - 127)
	=>
	1.00010110110000110001111 * 2^17
	=>
	100010110110000110.001111
	=>
	142726.234375
	=>
	142726.234		(VS2010结果显示，这里是如何截取的呢？)


### 2.双精度 double

双精度与单精度的不同在于存储的比特位数不一样。其转换方式与单精度是一样的。

#### 正序

	142726.24d
	=>
	100010110110000110.00111101011100001010001111010111
	=>
	1.0001011011000011000111101011100001010001111010111 * 2^17
	
	小数部分(52位，不足补0)
	0001011011000011000111101011100001010001111010111 000
	=>
	0001011011000011000111101011100001010001111010111000
	
	指数部分(11位，偏移量变成了1023)
	17 + 1023 = 1040 => 10000010000
	
	结合起来
	0 10000010000 0001011011000011000111101011100001010001111010111000
	=>
	0X0100000100000001011011000011000111101011100001010001111010111000


#### 逆序

	内存显示：
	b8 1e 85 eb 31 6c 01 41
	=>
	41 01 6c 31 eb 85 1e b8
	=>
	01000001 00000001 01101100 00110001 11101011 10000101 00011110 10111000
	=>
	0X0100000100000001011011000011000111101011100001010001111010111000


#### 还原

将正序的得到的结果与逆序得到的结果对比：

	0X0100000100000001011011000011000111101011100001010001111010111000
	0X0100000100000001011011000011000111101011100001010001111010111000

结果一致

将二进制结果还原：
	
	0100000100000001011011000011000111101011100001010001111010111000
	=>
	0   10000010000   0001011011000011000111101011100001010001111010111000
	=>
	1.0001011011000011000111101011100001010001111010111000 * 2^(10000010000-1023)
	=>
	1.0001011011000011000111101011100001010001111010111000 * 2^(1040-1023)
	=>
	1.0001011011000011000111101011100001010001111010111000 * 2^17
	=>
	100010110110000110.00111101011100001010001111010111000
	=>
	142726.24


### 3. 总结

通过上述对比单精度和双精度的同一个数在内存中的存储，我们大致就可以感受到：  

- **指数位决定了数值范围大小**
- **小数位决定了精度大小**
	

精度越高，则表示的浮点数越准确；范围越大，则能表示的浮点数越大。

---

## .NET中的浮点数

.Net中用于存储浮点数类型，有

- Single
- Double
- Decimal

三种类型，其中，Single表示单精度浮点数类型，Double表示双精度浮点数类型，Decimal相比于Double而言，精度更高，但是范围小了很多。  
它们的范围和精度分别为

| 类型 | 大致范围 | 精度 | .NET Framework 类型 |
| ----| ------- | ---- | ------------------- |
| float   | -3.4 × 10^38 到 +3.4 × 10^38              | 7 位           | Single |
| double  | ±5.0 × 10^−324 到 ±1.7 × 10^308           | 15 到 16 位    | Double |
| decimal | (-7.9 x 10^28 - 7.9 x 10^28) / (100 - 28) | 28-29 个有效位 | Decimal |

### 1.精度计算

小数位决定了精度。小数部分是23位比特，转换成10进制的精度：

	2^23 = 10^x
	=>
	x = 23log2
	=>
	x ≈ 6.92

网上的主流说法，二进制小数点的第一位永远都是1，可以省略，实际上二进制的精度为24，所以10进制的精度为7。 
同理，`52`位的小数部分，转换成10进制的精度，约等于`15.6`。


### 2.范围计算

指数位决定了范围。指数部分是8位比特，所以范围大致是：

	-2^128 - 2^128

计算结果大约为

	-3.40282366920938E+38 到 3.40282366920938E+38
	≈
	-3.4E+38 到 3.4E+38

---

## 参考

1. [float（C# 参考）](https://docs.microsoft.com/zh-cn/previous-versions/b1e65aza%28v%3dvs.120%29) 
2. [double（C# 参考）](https://docs.microsoft.com/zh-cn/previous-versions/678hzkk9%28v%3dvs.120%29)
3. [decimal（C# 参考）](https://docs.microsoft.com/zh-cn/previous-versions/364x0z75(v=vs.120))
4. [浮点数的范围和精度问题（从原理到结论）](https://blog.csdn.net/qq_16137569/article/details/79508091)
5. [单精度浮点数(float)、多精度浮点数(double)的区别，精度和范围和什么有关系](https://blog.csdn.net/leigelaile1/article/details/81558958)
6. [浮点数 - wikipedia](https://zh.wikipedia.org/wiki/%E6%B5%AE%E7%82%B9%E6%95%B0)
7. [IEEE 754 - wikipedia](https://zh.wikipedia.org/wiki/IEEE_754)
